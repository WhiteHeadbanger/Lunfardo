"""
Parser module for the Lunfardo programming language.

This module contains the Parser class which is responsible for parsing
the tokens generated by the lexer and constructing an Abstract Syntax Tree (AST).
It also includes the ParseResult class for managing the parsing process and results.
"""

from constants.tokens import *
from nodes import *
from errors import InvalidSyntaxBardo, InvalidTypeBardo, Bardo
from lunfardo_token import Token
from typing import Union, Self, Optional, Tuple, Callable

LunfardoNode = Union[
    NumeroNode,
    ChamuyoNode,
    CosoNode,
    MataburrosNode,
    PoneleQueAccessNode,
    PoneleQueAssignNode,
    AccessAndAssignNode,
    BinOpNode,
    UnaryOpNode,
    SiNode,
    ParaNode,
    MientrasNode,
    LaburoDefNode,
    ChetoDefNode,
    MethodCallNode,
    InstanceNode,
    InstanceVarAssignNode,
    InstanceVarAccessNode,
    CallNode,
    DevolverNode,
    ContinuarNode,
    RajarNode,
    ImportarNode,
    ProbaSiBardeaNode,
    BardeaNode
]

# MARK: Parser
class Parser:
    """
    Parser for the Lunfardo programming language.

    This class takes a list of tokens and constructs an Abstract Syntax Tree (AST)
    representing the structure and meaning of the Lunfardo code.
    """

    def __init__(self, tokens) -> None:
        """
        Initialize the Parser with a list of tokens.

        Args:
            tokens (list): A list of Token objects to be parsed.
        """
        self.tokens = tokens
        self.tok_idx = -1
        self.except_keyword_seen = False
        self.advance()

    def advance(self) -> Token:
        """
        Advance to the next token in the token list.

        Returns:
            Token: The current token after advancing.
        """
        self.tok_idx += 1
        self.update_current_tok()
        return self.current_tok

    def reverse(self, amount: int = 1) -> Token:
        """
        Move the token index backwards by the specified amount.

        Args:
            amount (int): The number of tokens to move backwards. Defaults to 1.

        Returns:
            Token: The current token after reversing.
        """
        self.tok_idx -= amount
        self.update_current_tok()
        return self.current_tok

    def update_current_tok(self) -> None:
        """
        Update the current token based on the current token index.
        """
        if self.tok_idx >= 0 and self.tok_idx < len(self.tokens):
            self.current_tok = self.tokens[self.tok_idx]

    def peek_next_token(self) -> Optional[Token]:
        """
        Look ahead to the next token without advancing the token index.

        Returns:
            Optional[Token]: The next token if it exists, None otherwise.
        """
        if self.tok_idx + 1 < len(self.tokens):
            return self.tokens[self.tok_idx + 1]
        return None

    def parse(self) -> Tuple[Optional["ParseResult"], bool]:
        """
        Parse the tokens and generate an AST.

        Returns:
            tuple: A tuple containing the ParseResult and a Boloodean indicating if EOF was reached.
        """
        if self.current_tok.type == TT_EOF:
            return None, True

        res = self.statements()
        if not res.error and self.current_tok.type != TT_EOF:
            return (
                res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba '+', '-', '*', '/', '^', '==', '!=', '<', '>', '<=', '>=', 'y' ó 'o'",
                    )
                ),
                False,
            )
        return res, False

    # MARK: Parser.statements
    def statements(self) -> "ParseResult":
        """
        Parse a sequence of statements.

        Returns:
            ParseResult: The result of parsing the statements.
        """
        res = ParseResult()
        statements = []
        pos_start = self.current_tok.pos_start.copy()

        while self.current_tok.type == TT_NEWLINE:
            res.register_advance()
            self.advance()

        res.reset_no_result()
        statement = res.register(self.statement())
        if res.error:
            return res

        statements.append(statement)

        more_statements = True

        while True:
            nl_count = 0

            while self.current_tok.type == TT_NEWLINE:
                res.register_advance()
                self.advance()
                nl_count += 1

            if self.current_tok.matches(TT_KEYWORD, "sibardea"):
                more_statements = False
                self.except_keyword_seen = True

            if nl_count == 0:
                more_statements = False

            if not more_statements:
                break
            
            # TODO si el statement no encuentra nodos válidos porque hay un "chau" como siguiente token, no debería devolver un error de invalidsyntaxerror,
            # sino que debería identificar que terminó el body y que no hay más statements, y luego seguir con el proceso normal.
            res.reset_no_result()
            stmnt = self.statement()
            error_or_statement = res.try_register(stmnt)

            if isinstance(error_or_statement, Bardo):
                return res.failure(error_or_statement)

            if res.no_result:
                self.reverse(res.to_reverse_count)
                more_statements = False
                continue

            if error_or_statement:
                statements.append(error_or_statement)

        return res.success(
            CosoNode(statements, pos_start, self.current_tok.pos_end.copy())
        )

    def statement(self) -> "ParseResult":
        """
        Parse a single statement in the Lunfardo language.

        This method handles various types of statements including 'devolver' (return),
        'continuar' (continue), 'rajar' (break), and expressions.

        Returns:
            ParseResult: The result of parsing the statement.
        """
        res = ParseResult()
        pos_start = self.current_tok.pos_start.copy()

        if self.current_tok.matches(TT_KEYWORD, "devolver"):
            res.register_advance()
            self.advance()

            expr = res.try_register(self.expr())

            if not expr:
                self.reverse(res.to_reverse_count)

            return res.success(
                DevolverNode(expr, pos_start, self.current_tok.pos_end.copy())
            )

        if self.current_tok.matches(TT_KEYWORD, "continuar"):
            res.register_advance()
            self.advance()

            return res.success(
                ContinuarNode(pos_start, self.current_tok.pos_end.copy())
            )

        if self.current_tok.matches(TT_KEYWORD, "rajar"):
            res.register_advance()
            self.advance()

            return res.success(RajarNode(pos_start, self.current_tok.pos_end.copy()))

        if self.current_tok.matches(TT_KEYWORD, "chau") or \
        self.current_tok.matches(TT_KEYWORD, "osi") or \
        self.current_tok.matches(TT_KEYWORD, "sino") or \
        self.current_tok.type == TT_EOF:
            res.no_result = True
            return res.success(None)
        
        expr = res.register(self.expr())
        if res.error:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'devolver', 'continuar', 'rajar', 'poneleque', 'si', 'para', 'mientras', 'laburo', numero, identificador, '+', '-', '(', '[' ó 'truchar'",
                )
            )

        return res.success(expr)

    # MARK: Parser.call
    def call(self) -> "ParseResult":
        """
        Parse a function call or atom in the Lunfardo language.

        This method handles parsing of function calls with arguments,
        as well as simple atoms when no call is present.

        Returns:
            ParseResult: The result of parsing the call or atom.
        """
        res = ParseResult()

        atom = res.register(self.atom())
        if res.error:
            return res

        # TODO Accessing a coso by index is currently done like this: coso / index. However I want replace it with the traditional coso[index]. Maybe using coso / index when
        # wanting to split a list in two. From 0 -> index and index + 1 -> end.
        # Here we can address the first issue.
        if self.current_tok.type == TT_LPAREN:
            res.register_advance()
            self.advance()

            arg_nodes = []

            if self.current_tok.type == TT_RPAREN:
                res.register_advance()
                self.advance()

            else:
                arg_node = res.register(self.expr())
                if res.error:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba ')' o una expresión.",
                        )
                    )

                arg_nodes.append(arg_node)

                while self.current_tok.type == TT_NEWLINE:
                    res.register_advance()
                    self.advance()

                while self.current_tok.type == TT_COMMA:
                    res.register_advance()
                    self.advance()

                    arg_node = res.register(self.expr())
                    if res.error:
                        return res.failure(
                            InvalidSyntaxBardo(
                                self.current_tok.pos_start,
                                self.current_tok.pos_end,
                                "Se esperaba ')' o una expresión.",
                            )
                        )
                    
                    arg_nodes.append(arg_node)

                if self.current_tok.type != TT_RPAREN:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba ',' ó ')'",
                        )
                    )

                res.register_advance()
                self.advance()

            return res.success(CallNode(atom, arg_nodes))

        return res.success(atom)

    # MARK: Parser.atom
    def atom(self) -> "ParseResult":
        """
        Parse an atomic expression in the Lunfardo language.

        This method handles parsing of various atomic expressions including:
        - Numeric literals (integers and floats)
        - String literals
        - Identifiers and variable access
        - Parenthesized expressions
        - List expressions
        - Dictionary expressions
        - Conditional expressions (if-else)
        - Loop expressions (for and while)
        - Function definitions
        - Class definitions
        - Instance creation

        Returns:
            ParseResult: The result of parsing the atomic expression.
        """
        res = ParseResult()
        tok = self.current_tok

        if tok.type in (TT_INT, TT_FLOAT):
            res.register_advance()
            self.advance()

            return res.success(NumeroNode(tok))

        if tok.type == TT_STRING:
            res.register_advance()
            self.advance()

            return res.success(ChamuyoNode(tok))

        if tok.type == TT_IDENTIFIER:
            res.register_advance()
            self.advance()
            if self.current_tok.type == TT_DOT:
                res.register_advance()
                self.advance()
                if self.current_tok.type == TT_IDENTIFIER:
                    if (
                        self.current_tok.matches(TT_IDENTIFIER, "arranque")
                        or self.peek_next_token().type == TT_LPAREN
                    ):
                        method_call_expr = res.register(self.method_call_expr(tok))
                        if res.error:
                            return res
                        return res.success(method_call_expr)

                    instance_var_expr = res.register(self.instance_var_expr(tok))

                    if res.error:
                        return res

                    return res.success(instance_var_expr)
            return res.success(PoneleQueAccessNode(tok))

        if tok.type == TT_LPAREN:
            res.register_advance()
            self.advance()

            expr = res.register(self.expr())

            if res.error:
                return res

            if self.current_tok.type == TT_RPAREN:
                res.register_advance()
                self.advance()

                return res.success(expr)

            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba ')'",
                )
            )

        if tok.type == TT_LSQUARE:
            list_expr = res.register(self.list_expr())

            if res.error:
                return res

            return res.success(list_expr)

        if tok.type == TT_LCURLY:
            dict_expr = res.register(self.dict_expr())

            if res.error:
                return res

            return res.success(dict_expr)

        if tok.matches(TT_KEYWORD, "si"):
            if_expr = res.register(self.if_expr())

            if res.error:
                return res

            return res.success(if_expr)

        if tok.matches(TT_KEYWORD, "para"):
            for_expr = res.register(self.for_expr())

            if res.error:
                return res

            return res.success(for_expr)

        if tok.matches(TT_KEYWORD, "mientras"):
            while_expr = res.register(self.while_expr())

            if res.error:
                return res

            return res.success(while_expr)

        if tok.matches(TT_KEYWORD, "laburo"):
            func_def = res.register(self.func_def())

            if res.error:
                return res

            return res.success(func_def)

        if tok.matches(TT_KEYWORD, "cheto"):
            class_def = res.register(self.class_def())

            if res.error:
                return res

            return res.success(class_def)

        if tok.matches(TT_KEYWORD, "nuevo"):
            instance = res.register(self.instance_expr())

            if res.error:
                return res

            return res.success(instance)

        if tok.matches(TT_KEYWORD, "importar"):
            import_expr = res.register(self.import_expr())

            if res.error:
                return res

            return res.success(import_expr)
        
        if tok.matches(TT_KEYWORD, "proba"):
            try_expr = res.register(self.try_expr())

            if res.error:
                return res

            return res.success(try_expr)
        
        if tok.matches(TT_KEYWORD, "bardea"):
            raise_expr = res.register(self.raise_expr())

            if res.error:
                return res
            
            return res.success(raise_expr)

        return res.failure(
            InvalidSyntaxBardo(
                tok.pos_start,
                tok.pos_end,
                "Se esperaba número, identificador, '+', '-', '(', '[', 'si', 'para', 'mientras', 'laburo' ó 'cheto'",
            )
        )

    def power(self) -> "ParseResult":
        """
        Parse a power expression in the Lunfardo language.

        This method handles expressions involving the power operator ('^').
        It uses the binary operation parsing method with the power token
        and calls the 'factor' method for the right-hand side of the operation.

        Returns:
            ParseResult: The result of parsing the power expression.
        """
        return self.bin_op(self.call, (TT_POW,), self.factor)

    # MARK: power | factor
    def factor(self) -> "ParseResult":
        """
        Parse a factor in the Lunfardo language.

        This method handles unary operations ('+' or '-') applied to factors,
        as well as power expressions. It processes the following grammar rule:
        factor : (PLUS|MINUS) factor | power

        Returns:
            ParseResult: The result of parsing the factor.
        """
        res = ParseResult()
        tok = self.current_tok

        if tok.type in (TT_PLUS, TT_MINUS):
            res.register_advance()
            self.advance()

            factor = res.register(self.factor())

            if res.error:
                return res

            return res.success(UnaryOpNode(tok, factor))

        return self.power()

    def term(self) -> "ParseResult":
        """
        Parse a term in the Lunfardo language.

        This method handles multiplication and division operations.
        It uses the binary operation parsing method with multiplication
        and division tokens, calling the 'factor' method for each operand.

        Returns:
            ParseResult: The result of parsing the term.
        """
        return self.bin_op(self.factor, (TT_MUL, TT_DIV))

    # MARK: term | comp_expr
    def comp_expr(self) -> "ParseResult":
        """
        Parse a comparison expression in the Lunfardo language.

        This method handles comparison operations and the 'truchar' (not) operation.
        It processes expressions involving equality, inequality, less than, greater than,
        less than or equal to, and greater than or equal to operators.

        The method also handles the 'truchar' keyword for logical negation.

        Returns:
            ParseResult: The result of parsing the comparison expression.
        """
        res = ParseResult()

        if self.current_tok.matches(TT_KEYWORD, "truchar"):
            op_tok = self.current_tok
            res.register_advance()
            self.advance()

            node = res.register(self.comp_expr())
            if res.error:
                return res

            return res.success(UnaryOpNode(op_tok, node))

        node = res.register(
            self.bin_op(self.arith_expr, (TT_EE, TT_NE, TT_LT, TT_GT, TT_LTE, TT_GTE))
        )

        if res.error:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba numero, identificador, '+', '-', '(', '[' ó truchar'",
                )
            )

        return res.success(node)

    def arith_expr(self) -> "ParseResult":
        """
        Parse an arithmetic expression in the Lunfardo language.

        This method handles addition and subtraction operations.
        It uses the binary operation parsing method with addition
        and subtraction tokens, calling the 'term' method for each operand.

        Returns:
            ParseResult: The result of parsing the arithmetic expression.
        """
        return self.bin_op(self.term, (TT_PLUS, TT_MINUS))

    # MARK: arith | list_expr
    def list_expr(self) -> "ParseResult":
        """
        Parse a list expression (coso) in the Lunfardo language.

        This method handles the parsing of list literals, including empty lists
        and lists with multiple elements. It processes the following syntax:
        [<expr>, <expr>, ...]

        The method expects square brackets and handles comma-separated expressions
        within the brackets. It creates a CosoNode representing the list.

        Returns:
            ParseResult: The result of parsing the list expression, containing
                        a CosoNode if successful.
        """
        res = ParseResult()

        element_nodes = []
        pos_start = self.current_tok.pos_start.copy()

        if self.current_tok.type != TT_LSQUARE:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba '['",
                )
            )

        res.register_advance()
        self.advance()

        # Empty list
        if self.current_tok.type == TT_RSQUARE:
            res.register_advance()
            self.advance()

        else:
            expr = res.register(self.expr())
            if res.error:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba una expresión.",
                    )
                )
            
            element_nodes.append(expr)

            while self.current_tok.type == TT_COMMA:
                res.register_advance()
                self.advance()

                expr = res.register(self.expr())
                if res.error:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba una expresión.",
                        )
                    )
                
                element_nodes.append(expr)

            if self.current_tok.type != TT_RSQUARE:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba ']'",
                    )
                )

            res.register_advance()
            self.advance()

        return res.success(
            CosoNode(element_nodes, pos_start, self.current_tok.pos_end.copy())
        )

    def dict_expr(self) -> "ParseResult":
        """
        Parse a dictionary expression (mataburros) in the Lunfardo language.

        This method handles the parsing of dictionary literals, including empty dictionaries
        and dictionaries with multiple key-value pairs. It processes the following syntax:
        {<key>: <value>, <key>: <value>, ...}

        The method expects curly braces and handles comma-separated key-value pairs
        within the braces. It creates a MataburrosNode representing the dictionary.

        Key features:
        - Handles empty dictionaries
        - Prevents coso (list) or mataburros (dict) from being used as keys
        - Allows updating of existing keys with new values
        - Ensures proper syntax with colons between keys and values

        Returns:
            ParseResult: The result of parsing the dictionary expression, containing
                        a MataburrosNode if successful.
        """
        res = ParseResult()

        pairs = [] # lista de pares (key_node, value_node)
        pos_start = self.current_tok.pos_start.copy()

        if self.current_tok.type != TT_LCURLY:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba '{'",
                )
            )

        res.register_advance()
        self.advance()

        # Coso de mataburros vacío
        if self.current_tok.type == TT_RCURLY:
            res.register_advance()
            self.advance()

        else:
            # Parsear el primer par clave-valor
            key_expr = self.expr()
            if isinstance(key_expr.node, (CosoNode, MataburrosNode)):
                return res.failure(
                    InvalidTypeBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Un coso ó mataburros no puede utilizarse como clave",
                    )
                )
            
            key_expr = res.register(key_expr)
            if res.error:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba una clave",
                    )
                )

            if not self.current_tok.type == TT_COLON:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba ':'",
                    )
                )

            res.register_advance()
            self.advance()

            value_expr = res.register(self.expr())
            if res.error:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba un valor",
                    )
                )
            
            pairs.append((key_expr, value_expr))
            
            # Si hay pares adicionales
            while self.current_tok.type == TT_COMMA:
                res.register_advance()
                self.advance()

                """ # Permitir una coma final luego del último valor
                if self.current_tok.type == TT_RCURLY:
                    break """

                key_expr = self.expr()
                if isinstance(key_expr.node, (CosoNode, MataburrosNode)):
                    return res.failure(
                        InvalidTypeBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Un coso ó mataburros no puede utilizarse como clave",
                        )
                    )
                
                key_expr = res.register(key_expr)
                if res.error:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba una clave",
                        )
                    )
                
                if not self.current_tok.type == TT_COLON:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba ':'",
                        )
                    )
                
                res.register_advance()
                self.advance()

                value_expr = res.register(self.expr())
                if res.error:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba un valor",
                        )
                    )
                
                # Si la clave ya fue definida, se actualiza su valor.
                # En caso contrario, se agrega el par
                key_value = key_expr.tok.value
                updated = False
                for i, (k, v) in enumerate(pairs):
                    if k.tok.value == key_value:
                        pairs[i] = (key_expr, value_expr)
                        updated = True
                        break
                if not updated:
                    pairs.append((key_expr, value_expr))

            if not self.current_tok.type == TT_RCURLY:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba '}'",
                    )
            )
            
            res.register_advance()
            self.advance()

        return res.success(
            MataburrosNode(pairs, pos_start, self.current_tok.pos_end.copy())
        )

    # MARK: Parse.if_expr
    def if_expr(self) -> "ParseResult":
        """
        Parse an if-expression in the Lunfardo language.

        This method handles the parsing of conditional expressions, including
        'si' (if), 'osi' (elif), and 'sino' (else) clauses. It processes the
        following general structure:
        si <condition> entonces <expr> [osi <condition> entonces <expr>]* [sino <expr>]

        The method delegates the parsing of individual cases to the if_expr_cases method.

        Returns:
            ParseResult: The result of parsing the if-expression, containing
                        a SiNode if successful.
        """
        res = ParseResult()
        all_cases = res.register(self.if_expr_cases("si"))

        if res.error:
            return res

        cases, else_case = all_cases
        return res.success(SiNode(cases, else_case))

    def if_expr_b(self) -> "ParseResult":
        """
        Parse an 'osi' (elif) clause in an if-expression.

        This method handles the parsing of additional conditional clauses
        in an if-expression, specifically the 'osi' (elif) cases. It delegates
        the actual parsing to the if_expr_cases method with 'osi' as the keyword.

        Returns:
            ParseResult: The result of parsing the 'osi' clause.
        """
        return self.if_expr_cases("osi")

    def if_expr_c(self) -> "ParseResult":
        """
        Parse the 'sino' (else) clause in an if-expression.

        This method handles the parsing of the final, optional 'sino' (else) clause
        in an if-expression. It can process two forms:
        1. A single-line else statement
        2. A multi-line else block terminated by 'chau'

        The method checks for the 'sino' keyword, advances the parser, and then
        processes either a single statement or a block of statements.

        Returns:
            ParseResult: The result of parsing the 'sino' clause, containing
                        a tuple of (statements, is_block) if an else clause is present,
                        or None if there is no else clause.
        """
        res = ParseResult()
        else_case = None

        if self.current_tok.matches(TT_KEYWORD, "sino"):
            res.register_advance()
            self.advance()

            if self.current_tok.type == TT_NEWLINE:
                res.register_advance()
                self.advance()

                statements = res.register(self.statements())
                if res.error:
                    return res

                else_case = (statements, True)
                
                if self.current_tok.matches(TT_KEYWORD, "chau"):
                    res.register_advance()
                    self.advance()

                else:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba 'chau'",
                        )
                    )

            else:
                expr = res.register(self.statement())
                if res.error:
                    return res

                else_case = (expr, False)

        return res.success(else_case)

    def if_expr_b_or_c(self) -> "ParseResult":
        """
        Parse either an 'osi' (elif) or 'sino' (else) clause in an if-expression.

        This method handles the parsing of additional clauses in an if-expression,
        determining whether to process an 'osi' (elif) clause or a 'sino' (else) clause.
        It acts as a decision point in the parsing of complex conditional expressions.

        If an 'osi' token is encountered, it delegates to if_expr_b for parsing.
        Otherwise, it delegates to if_expr_c to parse a potential 'sino' clause.

        Returns:
            ParseResult: The result of parsing either an 'osi' or 'sino' clause,
                        containing a tuple of (cases, else_case).
        """
        res = ParseResult()

        cases, else_case = [], None

        if self.current_tok.matches(TT_KEYWORD, "osi"):
            all_cases = res.register(self.if_expr_b())

            if res.error:
                return res

            cases, else_case = all_cases

        else:
            else_case = res.register(self.if_expr_c())
            if res.error:
                return res

        return res.success((cases, else_case))

    def if_expr_cases(self, case_keyword: str) -> "ParseResult":
        """
        Parse the cases of an if-expression in the Lunfardo language.

        This method handles the parsing of individual cases in an if-expression,
        including 'si' (if) and 'osi' (elif) cases. It processes the following structure:
        <case_keyword> <condition> entonces <expr> | (NEWLINE <statements> KEYWORD:chau)

        Args:
            case_keyword (str): The keyword indicating the type of case ('si' or 'osi').

        The method parses the condition, the 'entonces' keyword, and either a single
        expression or a block of statements. It also handles nested if-expressions
        by recursively calling if_expr_b_or_c for additional cases.

        Returns:
            ParseResult: The result of parsing the if-expression cases, containing
                        a tuple of (cases, else_case) if successful.
        """
        res = ParseResult()

        cases = []
        else_case = None

        if not self.current_tok.matches(TT_KEYWORD, case_keyword):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    f"Se esperaba '{case_keyword}'",
                )
            )

        res.register_advance()
        self.advance()

        condition = res.register(self.expr())

        if res.error:
            return res

        if not self.current_tok.matches(TT_KEYWORD, "entonces"):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'entonces'",
                )
            )

        res.register_advance()
        self.advance()

        if self.current_tok.type == TT_NEWLINE:
            res.register_advance()
            self.advance()

            statements = res.register(self.statements())

            if res.error:
                return res

            cases.append((condition, statements, True))

            if self.current_tok.matches(TT_KEYWORD, "chau"):
                res.register_advance()
                self.advance()

            else:
                all_cases = res.register(self.if_expr_b_or_c())

                if res.error:
                    return res

                new_cases, else_case = all_cases
                cases.extend(new_cases)

        else:
            expr = res.register(self.statement())

            if res.error:
                return res

            cases.append((condition, expr, False))

            all_cases = res.register(self.if_expr_b_or_c())

            if res.error:
                return res

            new_cases, else_case = all_cases
            cases.extend(new_cases)

        return res.success((cases, else_case))

    # MARK: Parse.for_expr
    def for_expr(self) -> "ParseResult":
        """
        Parse a 'para' (for) loop expression in the Lunfardo language.

        This method handles the parsing of for loop constructs with the following structure:
        para <identifier> = <start_value> hasta <end_value> [entre <step_value>] entonces
            <body>

        Key components:
        - Loop variable declaration and initialization
        - Range specification with 'hasta' (to) keyword
        - Optional step value with 'entre' keyword
        - Loop body, which can be a single statement or a block of statements

        The method creates a ParaNode representing the for loop structure.

        Returns:
            ParseResult: The result of parsing the for loop expression, containing
                        a ParaNode if successful.
        """
        res = ParseResult()

        if not self.current_tok.matches(TT_KEYWORD, "para"):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'para'",
                )
            )

        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_IDENTIFIER:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba identificador",
                )
            )

        var_name = self.current_tok

        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_EQ:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba '='",
                )
            )

        res.register_advance()
        self.advance()

        start_value = res.register(self.expr())

        if res.error:
            return res

        if not self.current_tok.matches(TT_KEYWORD, "hasta"):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'hasta'",
                )
            )

        res.register_advance()
        self.advance()

        end_value = res.register(self.expr())

        if res.error:
            return res

        if self.current_tok.matches(TT_KEYWORD, "entre"):
            res.register_advance()
            self.advance()

            step_value = res.register(self.expr())

            if res.error:
                return res

        else:
            step_value = None

        if not self.current_tok.matches(TT_KEYWORD, "entonces"):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'entonces'",
                )
            )

        res.register_advance()
        self.advance()

        if self.current_tok.type == TT_NEWLINE:
            res.register_advance()
            self.advance()

            body = res.register(self.statements())

            if res.error:
                return res

            if not self.current_tok.matches(TT_KEYWORD, "chau"):
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba 'chau'",
                    )
                )

            res.register_advance()
            self.advance()

            return res.success(
                ParaNode(var_name, start_value, end_value, step_value, body, True)
            )

        body = res.register(self.statement())

        if res.error:
            return res

        return res.success(
            ParaNode(var_name, start_value, end_value, step_value, body, False)
        )

    # MARK: Parse.while_expr
    def while_expr(self) -> "ParseResult":
        """
        Parse a 'mientras' (while) loop expression in the Lunfardo language.

        This method handles the parsing of while loop constructs with the following structure:
        mientras <condition> entonces
            <body>

        Key components:
        - Loop condition after the 'mientras' keyword
        - 'entonces' keyword to introduce the loop body
        - Loop body, which can be a single statement or a block of statements

        The method supports both single-line and multi-line while loop structures.
        For multi-line structures, it expects a 'chau' keyword to close the block.

        Returns:
            ParseResult: The result of parsing the while loop expression, containing
                        a MientrasNode if successful.
        """
        res = ParseResult()

        if not self.current_tok.matches(TT_KEYWORD, "mientras"):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'mientras'",
                )
            )

        res.register_advance()
        self.advance()

        condition = res.register(self.expr())

        if res.error:
            return res

        if not self.current_tok.matches(TT_KEYWORD, "entonces"):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'entonces'",
                )
            )

        res.register_advance()
        self.advance()

        if self.current_tok.type == TT_NEWLINE:
            res.register_advance()
            self.advance()

            body = res.register(self.statements())

            if res.error:
                return res

            if not self.current_tok.matches(TT_KEYWORD, "chau"):
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba 'chau'",
                    )
                )

            res.register_advance()
            self.advance()

            return res.success(MientrasNode(condition, body, True))

        # self.statement() allows for one-liners
        body = res.register(self.statement())

        if res.error:
            return res

        return res.success(MientrasNode(condition, body, False))

    # MARK: Parse.func_expr
    def func_def(self) -> "ParseResult":
        """
        Parse a function definition ('laburo') in the Lunfardo language.

        This method handles the parsing of function definitions with the following structure:
        laburo <identifier>(<parameters>) NEWLINE
            <body>
        chau

        Key components:
        - 'laburo' keyword to start the function definition
        - Function name (identifier)
        - Parameter list, which can include default values
        - Function body as a block of statements
        - 'chau' keyword to end the function definition

        The method supports parameters with optional default values.
        It creates a LaburoDefNode representing the function structure.

        Returns:
            ParseResult: The result of parsing the function definition, containing
                        a LaburoDefNode if successful.
        """
        res = ParseResult()

        if not self.current_tok.matches(TT_KEYWORD, "laburo"):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'laburo'",
                )
            )

        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_IDENTIFIER:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba identificador",
                )
            )

        var_name_tok = self.current_tok
        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_LPAREN:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba '('",
                )
            )

        res.register_advance()
        self.advance()
        arg_name_and_values = {}
        value = None

        if self.current_tok.type == TT_IDENTIFIER:
            arg_name_tok = self.current_tok

            res.register_advance()
            self.advance()

            if self.current_tok.type == TT_EQ:
                res.register_advance()
                self.advance()

                value = res.register(self.expr())

                if res.error:
                    return res

            arg_name_and_values[arg_name_tok] = value

            while self.current_tok.type == TT_COMMA:
                res.register_advance()
                self.advance()

                if self.current_tok.type != TT_IDENTIFIER:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba identificador",
                        )
                    )

                arg_name_tok = self.current_tok

                res.register_advance()
                self.advance()

                if self.current_tok.type == TT_EQ:
                    res.register_advance()
                    self.advance()

                    value = res.register(self.expr())

                    if res.error:
                        return res

                arg_name_and_values[arg_name_tok] = value

        if self.current_tok.type != TT_RPAREN:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba ')'",
                )
            )

        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_NEWLINE:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba nueva línea",
                )
            )

        res.register_advance()
        self.advance()

        body = res.register(self.statements())
        if res.error:
            return res

        if not self.current_tok.matches(TT_KEYWORD, "chau"):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'chau'",
                )
            )

        res.register_advance()
        self.advance()

        return res.success(
            LaburoDefNode(var_name_tok, arg_name_and_values, body, False)
        )

    def instance_expr(self) -> "ParseResult":
        """
        Parse an instance creation expression in the Lunfardo language.

        This method handles the parsing of object instantiation with the following structure:
        nuevo <class_name>(<arguments>)

        Key components:
        - 'nuevo' keyword to indicate object creation
        - Class name (identifier)
        - Optional argument list for the constructor

        The method creates an InstanceNode representing the object instantiation.

        Returns:
            ParseResult: The result of parsing the instance creation expression,
                        containing an InstanceNode if successful.
        """
        res = ParseResult()

        if not self.current_tok.matches(TT_KEYWORD, "nuevo"):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'nuevo'",
                )
            )

        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_IDENTIFIER:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba identificador",
                )
            )

        class_name = self.current_tok
        res.register_advance()
        self.advance()

        arg_nodes = []

        if self.current_tok.type == TT_LPAREN:
            res.register_advance()
            self.advance()

            if self.current_tok.type == TT_RPAREN:
                res.register_advance()
                self.advance()
            else:
                expr = res.register(self.expr())
                if res.error:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba ')' o una expresión",
                        )
                    )
                
                arg_nodes.append(expr)

                while self.current_tok.type == TT_COMMA:
                    res.register_advance()
                    self.advance()

                    expr = res.register(self.expr())
                    if res.error:
                        return res.failure(
                            InvalidSyntaxBardo(
                                self.current_tok.pos_start,
                                self.current_tok.pos_end,
                                "Se esperaba ')' o una expresión",
                            )
                        )
                    arg_nodes.append(expr)

                if self.current_tok.type != TT_RPAREN:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba ',' o ')'",
                        )
                    )

                res.register_advance()
                self.advance()

        return res.success(InstanceNode(class_name, arg_nodes))

    def class_def(self) -> "ParseResult":
        """
        Parse a class definition ('cheto') in the Lunfardo language.

        This method handles the parsing of class definitions with the following structure:
        cheto <class_name>
            <method_definitions>
        chau

        Key components:
        - 'cheto' keyword to start the class definition
        - Class name (identifier)
        - Method definitions, including a special 'arranque' (constructor) method
        - 'chau' keyword to end the class definition

        The method creates a ChetoDefNode representing the class structure,
        including all defined methods and the optional constructor.

        Returns:
            ParseResult: The result of parsing the class definition, containing
                        a ChetoDefNode if successful.
        """
        res = ParseResult()

        if not self.current_tok.matches(TT_KEYWORD, "cheto"):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'cheto'",
                )
            )

        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_IDENTIFIER:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba nombre de cheto",
                )
            )

        class_name = self.current_tok
        parent_class_name = None
        res.register_advance()
        self.advance()

        # Check if the class has a parent class to inherit from
        if self.current_tok.type == TT_LPAREN:
            res.register_advance()
            self.advance()

            if self.current_tok.type != TT_IDENTIFIER:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba identificador",
                    )
                )

            parent_class_name = self.current_tok
            res.register_advance()
            self.advance()

            if self.current_tok.type != TT_RPAREN:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba ')'",
                    )
                )

            res.register_advance()
            self.advance()

        if self.current_tok.type != TT_NEWLINE:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba nueva linea despues del nombre de cheto",
                )
            )

        methods = []
        arranque_method = None
        while self.current_tok.type == TT_NEWLINE:
            res.register_advance()
            self.advance()
            if self.current_tok.type == TT_NEWLINE:
                continue

            if self.current_tok.matches(TT_KEYWORD, "laburo"):
                method = res.register(self.func_def())
                if res.error:
                    return res
                if method.var_name_tok.value == "arranque":
                    arranque_method = method
                else:
                    methods.append(method)
            elif self.current_tok.matches(TT_KEYWORD, "chau"):
                break
            else:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba 'laburo' o 'chau'",
                    )
                )

        if not self.current_tok.matches(TT_KEYWORD, "chau"):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'chau'",
                )
            )

        res.register_advance()
        self.advance()

        return res.success(
            ChetoDefNode(class_name, methods, arranque_method, parent_class_name)
        )

    def method_call_expr(self, object_tok) -> "ParseResult":
        """
        Parse a method call expression in the Lunfardo language.

        This method handles the parsing of method calls on objects with the following structure:
        <object>.<method_name>(<arguments>)

        Parameters:
        object_tok (Token): The token representing the object on which the method is called.

        Key components:
        - Object token (passed as a parameter)
        - Method name (identifier)
        - Argument list (which can be empty)

        The method creates a MethodCallNode representing the method call structure.

        Returns:
            ParseResult: The result of parsing the method call expression,
                        containing a MethodCallNode if successful.
        """
        res = ParseResult()

        if self.current_tok.type != TT_IDENTIFIER:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba nombre de metodo",
                )
            )

        method_name = self.current_tok
        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_LPAREN:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba '('",
                )
            )

        res.register_advance()
        self.advance()
        arg_nodes = []

        if self.current_tok.type == TT_RPAREN:
            res.register_advance()
            self.advance()
        else:
            arg_node = res.register(self.expr())
            if res.error:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba ')' o una expresión",
                    )
                )
            
            arg_nodes.append(arg_node)

            while self.current_tok.type == TT_COMMA:
                res.register_advance()
                self.advance()

                arg_node = res.register(self.expr())
                if res.error:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba una expresión",
                        )
                    )
                
                arg_nodes.append(arg_node)

            if self.current_tok.type != TT_RPAREN:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba ')'",
                    )
                )

            res.register_advance()
            self.advance()

        return res.success(MethodCallNode(object_tok, method_name, arg_nodes))

    def instance_var_expr(self, object_tok) -> "ParseResult":
        """
        Parse an instance variable access expression in the Lunfardo language.

        This method handles the parsing of instance variable access with the structure:
        <object>.<variable_name>

        Parameters:
        object_tok (Token): The token representing the object whose variable is being accessed.

        The method creates an InstanceVarAccessNode representing the variable access.

        Returns:
            ParseResult: The result of parsing the instance variable access,
                        containing an InstanceVarAccessNode if successful.
        """
        res = ParseResult()

        if self.current_tok.type != TT_IDENTIFIER:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba un identificador",
                )
            )

        var_name = self.current_tok
        res.register_advance()
        self.advance()

        return res.success(InstanceVarAccessNode(object_tok, var_name))

    def import_expr(self) -> "ParseResult":
        """
        Parse an import expression in the Lunfardo language.
        """

        res = ParseResult()
        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_STRING:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "El nombre del modulo a importar debe ser un chamuyo",
                )
            )

        import_module_node = res.register(self.atom())
        if res.error:
            return res

        res.register_advance()
        self.advance()

        return res.success(ImportarNode(import_module_node))
    
    def try_expr(self) -> "ParseResult":
        """
        Parse a try-except expression in the Lunfardo language.
        """

        res = ParseResult()
        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_COLON:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba ':'"
                )
            )
        
        res.register_advance()
        self.advance()
        
        if self.current_tok.type != TT_NEWLINE:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba nueva linea"
                )
            )

        try_body = res.register(self.statements())
        if res.error:
            return res
        
        if not self.except_keyword_seen:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'sibardea'"
                )
            )
        
        self.except_keyword_seen = False
        
        res.register_advance()
        self.advance()

        if not (self.current_tok.type == TT_IDENTIFIER and self.current_tok.value in (
            'caracter_ilegal',
            'sintaxis_invalida',
            'caracter_esperado',
            'bardo_de_tipo',
            'bardo_de_indice',
            'bardo_de_clave',
            'bardo_de_valor'
        )):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba un bardo"
                )
            )
        
        error_name = self.current_tok.value

        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_COLON:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba ':'"
                )
            )
        
        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_NEWLINE:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba nueva linea"
                )
            )
        
        res.register_advance()
        self.advance()

        except_body = res.register(self.statements())
        if res.error:
            return res
        
        res.register_advance()
        self.advance()

        return res.success(
            ProbaSiBardeaNode(try_body, error_name, except_body)
        )
    
    def raise_expr(self) -> "ParseResult":
        """
        Parse a bardea expression (raise/throw) in the Lunfardo language.

        Returns:
            ParseResult: The result of parsing the expression, containing
                        the appropriate node type if successful.
        """
        res = ParseResult()
        pos_start = self.current_tok.pos_start.copy()
        res.register_advance()
        self.advance()

        if not (self.current_tok.type == TT_IDENTIFIER and self.current_tok.value in (
            'caracter_ilegal',
            'sintaxis_invalida',
            'caracter_esperado',
            'bardo_de_tipo',
            'bardo_de_indice',
            'bardo_de_clave',
            'bardo_de_valor'
        )):
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba un bardo"
                )
            )
        
        bardo_name = self.current_tok

        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_ARROW:
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba '->'"
                )
            )
        
        res.register_advance()
        self.advance()

        if self.current_tok.type != TT_STRING:
            return res.failure(
                InvalidTypeBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba un chamuyo"
                )
            )
        
        bardo_msg_node = res.register(self.atom())

        res.register_advance()
        self.advance()

        return res.success(
            BardeaNode(bardo_name, bardo_msg_node)
        )



    # MARK: Parse.expr
    def expr(self) -> "ParseResult":
        """
        Parse a general expression in the Lunfardo language.

        This method handles various types of expressions, including:
        - Variable assignments with 'poneleque'
        - Instance variable assignments
        - Binary operations with logical operators 'y' (and) and 'o' (or)

        Key components:
        - 'poneleque' keyword for variable assignments
        - Dot notation for instance variable access and assignment
        - Binary operations for complex expressions

        The method creates appropriate nodes (PoneleQueAssignNode, InstanceVarAssignNode,
        or BinOpNode) based on the parsed expression.

        Returns:
            ParseResult: The result of parsing the expression, containing
                        the appropriate node type if successful.
        """
        res = ParseResult()

        if self.current_tok.matches(TT_KEYWORD, "poneleque"):
            res.register_advance()
            self.advance()

            if self.current_tok.type != TT_IDENTIFIER:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba identificador",
                    )
                )

            var_name = self.current_tok

            res.register_advance()
            self.advance()

            if self.current_tok.type == TT_DOT:
                res.register_advance()
                self.advance()

                if self.current_tok.type != TT_IDENTIFIER:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba identificador",
                        )
                    )

                attr_name = self.current_tok
                res.register_advance()
                self.advance()

                if self.current_tok.type != TT_EQ:
                    return res.failure(
                        InvalidSyntaxBardo(
                            self.current_tok.pos_start,
                            self.current_tok.pos_end,
                            "Se esperaba '='",
                        )
                    )

                res.register_advance()
                self.advance()
                expr = res.register(self.expr())
                if res.error:
                    return res

                return res.success(InstanceVarAssignNode(var_name, attr_name, expr))

            if self.current_tok.type != TT_EQ:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba '='",
                    )
                )

            res.register_advance()
            self.advance()

            expr = res.register(self.expr())

            if res.error:
                return res

            return res.success(PoneleQueAssignNode(var_name, expr))
        
        if self.current_tok.type == TT_IDENTIFIER and self.peek_next_token().type == TT_EQ:
            var_name = self.current_tok

            res.register_advance()
            self.advance()

            if self.current_tok.type != TT_EQ:
                return res.failure(
                    InvalidSyntaxBardo(
                        self.current_tok.pos_start,
                        self.current_tok.pos_end,
                        "Se esperaba '='",
                    )
                )

            res.register_advance()
            self.advance()

            expr = res.register(self.expr())

            if res.error:
                return res

            return res.success(AccessAndAssignNode(var_name, expr))

        node = res.register(
            self.bin_op(self.comp_expr, ((TT_KEYWORD, "y"), (TT_KEYWORD, "o")))
        )

        if res.error:
            # MARK: me parece que aca solamente deberia retornar "res"
            return res.failure(
                InvalidSyntaxBardo(
                    self.current_tok.pos_start,
                    self.current_tok.pos_end,
                    "Se esperaba 'poneleque', 'si', 'para', 'mientras', 'laburo', numero, identificador, '+', '-', '(', '[' ó 'truchar'",
                )
            )

        return res.success(node)

    # MARK: Parse.bin_op
    def bin_op(
        self, func_a: Callable, ops: Tuple[Token], func_b: Optional[Callable] = None
    ) -> "ParseResult":
        """
        Parse binary operations in the Lunfardo language.

        This method is a generic parser for binary operations, handling various
        operator types based on the provided parameters.

        Args:
            func_a (function): The parsing function for the left operand.
            ops (tuple): A tuple of valid operator tokens for this binary operation.
            func_b (function, optional): The parsing function for the right operand.
                                        If None, func_a is used for both operands.

        The method creates a BinOpNode for each binary operation encountered,
        chaining multiple operations if present.

        Returns:
            ParseResult: The result of parsing the binary operation(s),
                        containing a BinOpNode or chain of BinOpNodes if successful.
        """
        if func_b is None:
            func_b = func_a

        res = ParseResult()
        left = res.register(func_a())

        if res.error:
            return res

        while (
            self.current_tok.type in ops
            or (self.current_tok.type, self.current_tok.value) in ops
        ):
            op_tok = self.current_tok
            res.register_advance()
            self.advance()
            right = res.register(func_b())

            if res.error:
                return res

            left = BinOpNode(left, op_tok, right)

        return res.success(left)


# MARK: ParseResult
class ParseResult:
    """
    Represents the result of a parsing operation.

    This class keeps track of the parsed node, any errors encountered,
    and manages the advancement count during parsing.
    """

    def __init__(self) -> None:
        self.error = None
        self.node = None
        self.last_registered_advance_count = 0
        self.advance_count = 0
        self.to_reverse_count = 0
        self.no_result = False

    def register_advance(self) -> None:
        self.last_registered_advance_count = 1
        self.advance_count += 1

    def register(self, res) -> LunfardoNode:
        self.last_registered_advance_count = res.advance_count
        self.advance_count += res.advance_count
        if res.error:
            self.error = res.error

        return res.node

    def try_register(self, res) -> LunfardoNode:
        if res.error:
            self.to_reverse_count = res.advance_count
            return res.error
        
        if not res.node:
            self.no_result = True
            self.to_reverse_count = res.advance_count
            return None

        return self.register(res)

    def success(self, node) -> Self:
        self.node = node
        return self

    def failure(self, error) -> Self:
        if not self.error or self.last_registered_advance_count == 0:
            self.error = error
        return self
    
    def reset_no_result(self):
        self.no_result = False
